// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hostManager.proto

/*
Package HostManager is a generated protocol buffer package.

It is generated from these files:
	hostManager.proto

It has these top-level messages:
	PrecheckRequest
	InitOrPrecheckReply
	LoginInfo
	TaskResult
	InitRequest
	InstallRequest
	InstallJobs
	InstallMessage
*/
package HostManager

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PrecheckRequest struct {
	LoginInfos []*LoginInfo `protobuf:"bytes,1,rep,name=loginInfos" json:"loginInfos,omitempty"`
}

func (m *PrecheckRequest) Reset()                    { *m = PrecheckRequest{} }
func (m *PrecheckRequest) String() string            { return proto.CompactTextString(m) }
func (*PrecheckRequest) ProtoMessage()               {}
func (*PrecheckRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PrecheckRequest) GetLoginInfos() []*LoginInfo {
	if m != nil {
		return m.LoginInfos
	}
	return nil
}

type InitOrPrecheckReply struct {
	Results []*TaskResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *InitOrPrecheckReply) Reset()                    { *m = InitOrPrecheckReply{} }
func (m *InitOrPrecheckReply) String() string            { return proto.CompactTextString(m) }
func (*InitOrPrecheckReply) ProtoMessage()               {}
func (*InitOrPrecheckReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *InitOrPrecheckReply) GetResults() []*TaskResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type LoginInfo struct {
	Host     string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	UserName string `protobuf:"bytes,3,opt,name=userName" json:"userName,omitempty"`
	Passwd   string `protobuf:"bytes,4,opt,name=passwd" json:"passwd,omitempty"`
}

func (m *LoginInfo) Reset()                    { *m = LoginInfo{} }
func (m *LoginInfo) String() string            { return proto.CompactTextString(m) }
func (*LoginInfo) ProtoMessage()               {}
func (*LoginInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *LoginInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LoginInfo) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *LoginInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *LoginInfo) GetPasswd() string {
	if m != nil {
		return m.Passwd
	}
	return ""
}

type TaskResult struct {
	Host    string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Message string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	Reason  string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
}

func (m *TaskResult) Reset()                    { *m = TaskResult{} }
func (m *TaskResult) String() string            { return proto.CompactTextString(m) }
func (*TaskResult) ProtoMessage()               {}
func (*TaskResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TaskResult) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *TaskResult) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *TaskResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TaskResult) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type InitRequest struct {
	Labels     map[string]string `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	LoginInfos []*LoginInfo      `protobuf:"bytes,2,rep,name=loginInfos" json:"loginInfos,omitempty"`
}

func (m *InitRequest) Reset()                    { *m = InitRequest{} }
func (m *InitRequest) String() string            { return proto.CompactTextString(m) }
func (*InitRequest) ProtoMessage()               {}
func (*InitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InitRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *InitRequest) GetLoginInfos() []*LoginInfo {
	if m != nil {
		return m.LoginInfos
	}
	return nil
}

type InstallRequest struct {
	Labels map[string]string       `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Jobs   map[string]*InstallJobs `protobuf:"bytes,2,rep,name=jobs" json:"jobs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InstallRequest) Reset()                    { *m = InstallRequest{} }
func (m *InstallRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallRequest) ProtoMessage()               {}
func (*InstallRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *InstallRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *InstallRequest) GetJobs() map[string]*InstallJobs {
	if m != nil {
		return m.Jobs
	}
	return nil
}

type InstallJobs struct {
	AnsibleJobs []string `protobuf:"bytes,1,rep,name=ansibleJobs" json:"ansibleJobs,omitempty"`
}

func (m *InstallJobs) Reset()                    { *m = InstallJobs{} }
func (m *InstallJobs) String() string            { return proto.CompactTextString(m) }
func (*InstallJobs) ProtoMessage()               {}
func (*InstallJobs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InstallJobs) GetAnsibleJobs() []string {
	if m != nil {
		return m.AnsibleJobs
	}
	return nil
}

type InstallMessage struct {
	Job     string `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Host    string `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Step    int32  `protobuf:"varint,4,opt,name=step" json:"step,omitempty"`
	Name    string `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	Status  string `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Message string `protobuf:"bytes,7,opt,name=message" json:"message,omitempty"`
	Ok      int32  `protobuf:"varint,8,opt,name=ok" json:"ok,omitempty"`
	Changed int32  `protobuf:"varint,9,opt,name=changed" json:"changed,omitempty"`
	Unreach int32  `protobuf:"varint,10,opt,name=unreach" json:"unreach,omitempty"`
	Failed  int32  `protobuf:"varint,11,opt,name=failed" json:"failed,omitempty"`
}

func (m *InstallMessage) Reset()                    { *m = InstallMessage{} }
func (m *InstallMessage) String() string            { return proto.CompactTextString(m) }
func (*InstallMessage) ProtoMessage()               {}
func (*InstallMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *InstallMessage) GetJob() string {
	if m != nil {
		return m.Job
	}
	return ""
}

func (m *InstallMessage) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InstallMessage) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *InstallMessage) GetStep() int32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *InstallMessage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InstallMessage) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *InstallMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *InstallMessage) GetOk() int32 {
	if m != nil {
		return m.Ok
	}
	return 0
}

func (m *InstallMessage) GetChanged() int32 {
	if m != nil {
		return m.Changed
	}
	return 0
}

func (m *InstallMessage) GetUnreach() int32 {
	if m != nil {
		return m.Unreach
	}
	return 0
}

func (m *InstallMessage) GetFailed() int32 {
	if m != nil {
		return m.Failed
	}
	return 0
}

func init() {
	proto.RegisterType((*PrecheckRequest)(nil), "HostManager.PrecheckRequest")
	proto.RegisterType((*InitOrPrecheckReply)(nil), "HostManager.InitOrPrecheckReply")
	proto.RegisterType((*LoginInfo)(nil), "HostManager.LoginInfo")
	proto.RegisterType((*TaskResult)(nil), "HostManager.TaskResult")
	proto.RegisterType((*InitRequest)(nil), "HostManager.InitRequest")
	proto.RegisterType((*InstallRequest)(nil), "HostManager.InstallRequest")
	proto.RegisterType((*InstallJobs)(nil), "HostManager.InstallJobs")
	proto.RegisterType((*InstallMessage)(nil), "HostManager.InstallMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for HostManager service

type HostManagerClient interface {
	Precheck(ctx context.Context, in *PrecheckRequest, opts ...grpc.CallOption) (*InitOrPrecheckReply, error)
	InitHosts(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitOrPrecheckReply, error)
	Install(ctx context.Context, in *InstallRequest, opts ...grpc.CallOption) (HostManager_InstallClient, error)
}

type hostManagerClient struct {
	cc *grpc.ClientConn
}

func NewHostManagerClient(cc *grpc.ClientConn) HostManagerClient {
	return &hostManagerClient{cc}
}

func (c *hostManagerClient) Precheck(ctx context.Context, in *PrecheckRequest, opts ...grpc.CallOption) (*InitOrPrecheckReply, error) {
	out := new(InitOrPrecheckReply)
	err := grpc.Invoke(ctx, "/HostManager.HostManager/Precheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostManagerClient) InitHosts(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitOrPrecheckReply, error) {
	out := new(InitOrPrecheckReply)
	err := grpc.Invoke(ctx, "/HostManager.HostManager/InitHosts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostManagerClient) Install(ctx context.Context, in *InstallRequest, opts ...grpc.CallOption) (HostManager_InstallClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_HostManager_serviceDesc.Streams[0], c.cc, "/HostManager.HostManager/Install", opts...)
	if err != nil {
		return nil, err
	}
	x := &hostManagerInstallClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type HostManager_InstallClient interface {
	Recv() (*InstallMessage, error)
	grpc.ClientStream
}

type hostManagerInstallClient struct {
	grpc.ClientStream
}

func (x *hostManagerInstallClient) Recv() (*InstallMessage, error) {
	m := new(InstallMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for HostManager service

type HostManagerServer interface {
	Precheck(context.Context, *PrecheckRequest) (*InitOrPrecheckReply, error)
	InitHosts(context.Context, *InitRequest) (*InitOrPrecheckReply, error)
	Install(*InstallRequest, HostManager_InstallServer) error
}

func RegisterHostManagerServer(s *grpc.Server, srv HostManagerServer) {
	s.RegisterService(&_HostManager_serviceDesc, srv)
}

func _HostManager_Precheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostManagerServer).Precheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HostManager.HostManager/Precheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostManagerServer).Precheck(ctx, req.(*PrecheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostManager_InitHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostManagerServer).InitHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HostManager.HostManager/InitHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostManagerServer).InitHosts(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostManager_Install_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HostManagerServer).Install(m, &hostManagerInstallServer{stream})
}

type HostManager_InstallServer interface {
	Send(*InstallMessage) error
	grpc.ServerStream
}

type hostManagerInstallServer struct {
	grpc.ServerStream
}

func (x *hostManagerInstallServer) Send(m *InstallMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _HostManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "HostManager.HostManager",
	HandlerType: (*HostManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Precheck",
			Handler:    _HostManager_Precheck_Handler,
		},
		{
			MethodName: "InitHosts",
			Handler:    _HostManager_InitHosts_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Install",
			Handler:       _HostManager_Install_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hostManager.proto",
}

func init() { proto.RegisterFile("hostManager.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 657 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xe1, 0x6e, 0xd3, 0x3e,
	0x10, 0x5f, 0xd2, 0xb5, 0x5d, 0x2e, 0xd2, 0xfe, 0x9b, 0xff, 0x68, 0x58, 0x65, 0x48, 0x55, 0x00,
	0x31, 0xf1, 0x21, 0x65, 0x43, 0x42, 0x6c, 0x42, 0x42, 0x9a, 0x84, 0x58, 0xd1, 0x06, 0x25, 0xe2,
	0x05, 0x9c, 0xd6, 0x4b, 0xd3, 0xa6, 0x76, 0x88, 0xdd, 0xa1, 0x7e, 0x43, 0x3c, 0x02, 0x7c, 0xe3,
	0x61, 0x78, 0x09, 0x5e, 0x81, 0x07, 0x41, 0x76, 0xec, 0x36, 0x2d, 0xdd, 0x34, 0x89, 0x6f, 0xfe,
	0xf9, 0x7e, 0x77, 0xe7, 0xdf, 0xf9, 0xee, 0x60, 0x77, 0xc8, 0x85, 0xbc, 0x20, 0x8c, 0x24, 0xb4,
	0x08, 0xf3, 0x82, 0x4b, 0x8e, 0xfc, 0xb3, 0xc5, 0x55, 0x6b, 0x3f, 0xe1, 0x3c, 0xc9, 0x68, 0x87,
	0xe4, 0x69, 0x87, 0x30, 0xc6, 0x25, 0x91, 0x29, 0x67, 0xa2, 0xa4, 0x06, 0x5d, 0xf8, 0xaf, 0x57,
	0xd0, 0xfe, 0x90, 0xf6, 0xc7, 0x11, 0xfd, 0x34, 0xa5, 0x42, 0xa2, 0xe7, 0x00, 0x19, 0x4f, 0x52,
	0xd6, 0x65, 0x97, 0x5c, 0x60, 0xa7, 0x5d, 0x3b, 0xf0, 0x8f, 0xf6, 0xc2, 0x4a, 0xc8, 0xf0, 0xdc,
	0x9a, 0xa3, 0x0a, 0x33, 0x38, 0x83, 0xff, 0xbb, 0x2c, 0x95, 0xef, 0x8b, 0x45, 0xc0, 0x3c, 0x9b,
	0xa1, 0x43, 0x68, 0x16, 0x54, 0x4c, 0x33, 0x69, 0x63, 0xdd, 0x5d, 0x8a, 0xf5, 0x91, 0x88, 0x71,
	0xa4, 0xed, 0x91, 0xe5, 0x05, 0x09, 0x78, 0xf3, 0x14, 0x08, 0xc1, 0xa6, 0x52, 0x88, 0x9d, 0xb6,
	0x73, 0xe0, 0x45, 0xfa, 0xac, 0xee, 0x72, 0x5e, 0x48, 0xec, 0xb6, 0x9d, 0x83, 0x7a, 0xa4, 0xcf,
	0xa8, 0x05, 0x5b, 0x53, 0x41, 0x8b, 0x77, 0x64, 0x42, 0x71, 0x4d, 0x73, 0xe7, 0x18, 0xed, 0x41,
	0x23, 0x27, 0x42, 0x7c, 0x1e, 0xe0, 0x4d, 0x6d, 0x31, 0x28, 0x18, 0x01, 0x2c, 0xf2, 0xaf, 0xcd,
	0xb4, 0x07, 0x0d, 0x21, 0x89, 0x9c, 0x0a, 0x9d, 0xcb, 0x8b, 0x0c, 0x42, 0x18, 0x9a, 0x13, 0x2a,
	0x04, 0x49, 0x6c, 0x32, 0x0b, 0x95, 0x47, 0x41, 0x89, 0xe0, 0xcc, 0xe6, 0x2a, 0x51, 0xf0, 0xd3,
	0x01, 0x5f, 0xd5, 0xc7, 0x96, 0xf9, 0x25, 0x34, 0x32, 0x12, 0xd3, 0xcc, 0x96, 0xe5, 0xe1, 0x52,
	0x59, 0x2a, 0xcc, 0xf0, 0x5c, 0xd3, 0x5e, 0x33, 0x59, 0xcc, 0x22, 0xe3, 0xb3, 0xf2, 0x49, 0xee,
	0x6d, 0x3f, 0xa9, 0x75, 0x0c, 0x7e, 0x25, 0x1c, 0xda, 0x81, 0xda, 0x98, 0xce, 0x8c, 0x62, 0x75,
	0x44, 0x77, 0xa0, 0x7e, 0x45, 0xb2, 0x29, 0x35, 0x7a, 0x4b, 0x70, 0xe2, 0xbe, 0x70, 0x82, 0x1f,
	0x2e, 0x6c, 0x77, 0x99, 0x90, 0x24, 0xcb, 0xac, 0x86, 0x57, 0x2b, 0x1a, 0x1e, 0xaf, 0x68, 0xa8,
	0x92, 0xd7, 0xca, 0x38, 0x86, 0xcd, 0x11, 0x8f, 0xad, 0x80, 0x47, 0x37, 0xb9, 0xbf, 0xe5, 0xb1,
	0x71, 0xd6, 0x2e, 0xff, 0xa0, 0xa4, 0xf5, 0x01, 0xbc, 0x79, 0xb4, 0x35, 0x8e, 0x61, 0xd5, 0xd1,
	0x3f, 0xc2, 0xeb, 0x5e, 0xa5, 0xfc, 0xab, 0xc5, 0xe9, 0xa8, 0xcf, 0x9d, 0x5b, 0x50, 0x1b, 0x7c,
	0xc2, 0x44, 0x1a, 0x67, 0x54, 0x41, 0x5d, 0x1d, 0x2f, 0xaa, 0x5e, 0x05, 0x5f, 0x16, 0xd5, 0xbc,
	0x30, 0x9d, 0xb3, 0x03, 0xb5, 0x11, 0x8f, 0xed, 0x4b, 0x46, 0x3c, 0x56, 0x1d, 0x29, 0x67, 0xb9,
	0x55, 0xa0, 0xcf, 0xf3, 0x2e, 0xad, 0x2d, 0xcf, 0x83, 0x90, 0x34, 0xd7, 0x1d, 0x57, 0x8f, 0xf4,
	0x59, 0xdd, 0x31, 0x35, 0x0b, 0xf5, 0x92, 0xc7, 0xcc, 0x1c, 0x98, 0x6e, 0x6e, 0x5c, 0xd7, 0xcd,
	0xcd, 0xe5, 0x6e, 0xde, 0x06, 0x97, 0x8f, 0xf1, 0x96, 0x8e, 0xeb, 0xf2, 0xb1, 0x62, 0xf6, 0x87,
	0x84, 0x25, 0x74, 0x80, 0x3d, 0x7d, 0x69, 0xa1, 0xb2, 0x4c, 0x59, 0x41, 0x49, 0x7f, 0x88, 0xa1,
	0xb4, 0x18, 0xa8, 0xb2, 0x5e, 0x92, 0x34, 0xa3, 0x03, 0xec, 0x6b, 0x83, 0x41, 0x47, 0xdf, 0x5c,
	0xa8, 0x6e, 0x2a, 0xc4, 0x61, 0xcb, 0xae, 0x0e, 0xb4, 0xbf, 0x54, 0xf4, 0x95, 0x15, 0xd5, 0x6a,
	0xff, 0x35, 0x2b, 0x2b, 0x5b, 0x27, 0x78, 0xf0, 0xf5, 0xd7, 0xef, 0xef, 0xee, 0xfd, 0x00, 0x77,
	0xae, 0x0e, 0x3b, 0xaa, 0x46, 0x93, 0x92, 0xdc, 0xc9, 0x0d, 0xed, 0xc4, 0x79, 0x82, 0xba, 0xe0,
	0x29, 0x5f, 0x15, 0x4b, 0x20, 0x7c, 0xdd, 0xfc, 0xdd, 0x22, 0xdb, 0x06, 0x7a, 0x03, 0x4d, 0xf3,
	0x9b, 0xe8, 0xde, 0x0d, 0x5d, 0xdc, 0x5a, 0x6b, 0x34, 0x0d, 0x10, 0x6c, 0x3c, 0x75, 0x4e, 0x8f,
	0x21, 0xe8, 0xf3, 0x49, 0x18, 0xa7, 0x2c, 0x89, 0x49, 0x4c, 0x42, 0xf5, 0x76, 0x32, 0x98, 0xa4,
	0x2c, 0xac, 0xec, 0xf9, 0xd3, 0x5d, 0x15, 0xc5, 0xbe, 0xa1, 0xa7, 0x36, 0x79, 0xcf, 0x89, 0x1b,
	0x7a, 0xa5, 0x3f, 0xfb, 0x13, 0x00, 0x00, 0xff, 0xff, 0x84, 0xa1, 0x08, 0x8e, 0x12, 0x06, 0x00,
	0x00,
}
